Интеллектуальные указатели
===

В С++11 есть 4 *интеллектуальных указателя*: *std::auto_ptr*, *std::unique_ptr*, *std::shared_ptr* и *std::weak_ptr*.
*std::auto_ptr* пришёл из C++98 и является устаревшим. *std::unique_ptr* во всех смыслах лучше *std::auto_ptr*.

## 4.1 Используйте *std::unique_ptr* для управления ресурсами путём исключительного владения.

*std::unique* имеет тот же размер, что и обычный указатель, а для большинства операций выполняются такие же команды.

В процессе конструирование объект *std::unique+ptr* можно настроить для использование *пользовательских удалителей (custom deleters)*.

```cpp
class Investment {                     // Инвестиции
public:
    virtual ~Investment ();            // Важная часть дизайна
};
class Stock :
    public Investment { /* ... */ };   // Акции
class Bond :
    public Investment { /* ... */ };   // Облигации
class RealEstate :
    public Investment { /* ... */ };   // Недвижимость

auto delInvmt = [] (Investment* pInvestment)
    {
        makeLogEntry (pInvestment);
        delete pInvestment;
    }
    
template <typename... Ts>
auto makeInvestment (Ts&&... params)    // Фабричная функция (C++14)
{
    std::unique_ptr <Investment, decltype (delInvmt)> pInv (nullptr, delInvmt);
    if ( /* Stock */ )
    {
        pInv.reset (new Stock (std::forward <Ts> (params)...));
    }
    else if ( /* Bond */ )
    {
        pInv.reset (new Bond (std::forward <Ts> (params)...));
    }
    else if ( /* RealEstate */ )
    {
        pInv.reset (new RealEstate (std::forward <Ts> (params)...));
    }
    
    return pInv;
}
```

Как только в *std::unique_ptr* появляется пользовательские удалители, его размер увеличивается на указатель. Но это происходит не всегда, а когда указывается функция. В случае *функциональных объектов без состояний* (например, лямба-выражения без захватов), увеличение размера не происходит, поэтому разумно пользоваться в качестве пользовательских удалителей *лямба-выражениями*.

Благодаря тому, что *std::unique_ptr* имеет две разновидности: *std::unique_ptr <T>* и *std::unique_ptr <T[]>*, т.е. для объектов и массивов, то не возникает неопределённости на какую сущность указывает *std::unique_ptr*. Но использовать встроенные массивы разумно разве что для С-образного API.

*std::unique_ptr* - способ выражения исключительного владения на С++11. Но очень привлекательно то, что его можно легко и эффективно преобразовать в *std::shared_ptr*:  
```cpp
std::shared_ptr <Investment> sharedPointer = makeInvestment (args);
```

Благодаря этому *std::unique_ptr* очень хорошо подходит для фабричных функций, ведь последние не знают кто будет владеть объектом: один или совместно.

### <center>Следует запомнить</center>
* *std::unique_ptr* представляет собой маленький, быстрый, предназначенный только для перемещения интеллектуальный указатель для управления ресурсами с семантикой исключительного владения.
* По умолчанию освобождение ресурсов выполняется с помощью оператора *delete*, но могут применяться и *пользовательские удалители*. Удалители без состояний и указатели на функции в качестве удалителей увеличивают размеры объектов *std::unique_ptr*.
* Интеллектуальные указатели *std::unique_ptr* легко преобразуются в интеллектуальные указатели *std::shared_ptr*.

## 4.2 Используйте *std::shared_ptr* для управления ресурсами путём совместного владения

Благодаря совместному владению, в *sdt::shared_ptr* есть счётчик ссылок. Это значит, что он атамрный и операции его изменения дорогостоящи.

При перемещающем конструировании этот счётчик не меняется, следовательно такие операции дешёвые.

* Размер *sdt::shared_ptr* в два раза больше размера обычного указателя
* Память счётчика ссылок должна выделяться динамически (кроме *std::make_shared*)
* Инкремент и декремент счётчика должны быть атомарными

Для *std::unique_std* тип удалителя является частью типа интеллектуального указателя
Для *sdt::shared_ptr*это не так:
```cpp
auto loggingDel = [] (Widget* pw)
    {
        makeLogEntry (pw);
        delete pw;
    }
    
std::unique_ptr <Widget, decltype (loggingDel)
                > upw (new Widget, loggingDel);
                
std::shared_ptr <Widget> spw (new Widget, loggingDel);
```

В отличие от *std::unique_ptr*, *std::shared_ptr* с разными удалителями можно хранить в массиве.

*Управляющий блок* есть для каждого объекта, на которого ссылается *std::shared_ptr*.
*Управляющий блок*:
* Счётчик ссылок
* Слабый счётчик
* Прочие данные (пользовательский удалитель, распределитель и т.п.)

Правила при создании управляющего блока:
* Функция *std::make_shared* (см. раздел 4.4) всегда создаёт управляющий блок
* Управляющий блок создаётся тогда, когда *std:shared_ptr* создаётся из указателя с исключительным влдаением (т.е. std::unique_ptr или std::auto_ptr)
* Когда конструктор *std::shared_ptr* вызывается с обычным указателем, он создаёт управляющий блок

Последнее правило наталкивает на мысль, что если создать два *std::shared_ptr* от обычного, то будет неопределённое поведение. Простым решением этой проблемы - это передавать непосредственно результат оператора *new* или аналогично с другими указателями. Т.е. не создавать переменных, хранящих обычные указатели.

Далее возникает вопрос: что если в функции-члене вызывается *std::shared_ptr*, который много раз может принять this? Это снова неопределённое поведение:
```cpp
class Widget {
public:
    void process ();
};

std::vector <std::shared_ptr <Widget>> processedWidget;


void Widget::process () {
    processedWidget.emplace_back (this);    // Это неправильно!
}
```

Но что если на этот объект Widget снаружи уже указывает *std::shared_ptr*? Тогда у нас неопределённое поведение!

Но можно и безопансо создавать *std::shared_ptr* из *this:
```cpp
class Widget : public std::enable_shared_from_this <Widget> {
public:
    void process ();
};

// ...

void Widget::process () {
    processedWidget.emplace_back (shared_from_this ());    // Это верно!
}
```

Идея производного класса, порождённого от базового класса, шаблонизированного производным, - известный шаблон проетирования. Она называеся *странно повторяющийся шаблон* (*The Curiously Recurring Template Pattern - CRTP*).

Шаблон *std::enable_shared_from_this* определяет функцию-член *shared_from_this*, которая создаёт *std:shared_ptr* для текущего объекта, но деалет это, не дублируя управляющие блоки. *std::shared_from_this* полагается на то, что у этого объекта уже есть управляющий блок, иначе будет неопр. поведение, хотя обычно *std::shared_from_this* генерирует исключение.

Чтобы клиенты не вызывали методы, где используется *std::shared_from_this*,  конструкторы объявляют как private и заставляют клиентов создвать объекты через фабричные функции:
```cpp
class Widget : public std::enable_shared_from_this <Widget>
{
public:
    // Фабричная функция, пересылающая аргументы закрытому конструктору
    template <typename... Ts>
    static std::shared_ptr <Widget> create (Ts&&... params);
    // ...
    void process ();    // Как и ранее
    
private:
    // Конструкторы
};
```

Управляющий блок обычно имеет размер в несколько слов, но может и больше. Также в *std::shared_ptr* есть виртуальные функции, которые тоже замедляют работу, но они обычно используются один раз - для вызова деструктора.

В отличие от *std::unique_ptr*, *std::shared_ptr* не могут работать с массивами! Не существует *std::share_ptr <T[]>*. *std::shared_ptr* не имеет *operator[]*, так что даже если создать массив, по нему неудобно ходить.

### <center>Следует запомнить</center>
* *std::shared_ptr* предоставляет удобный подход к управлению времени жизни произвольных ресурсов, аналогичный сборке мусора.
* По сравнению с *std::unique_ptr* объекты *std::shared_ptr* обычно в два раза больше, привносят накрадные расхды на работу с управляющими блоками и требуют атомарной работы со счётчиком ссылок
* Освобождение ресурсов по умолчанию выполняется при помощи оператора *delete*, однако поддеживаются и пользовательские удалители. Тип удалителя не влияет на тип указателя *std::shared_ptr*.
* Избегайте создание указателей *std::shared_ptr* из переменных, тип которых - обычный встроенный указатель.























