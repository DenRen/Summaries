Интеллектуальные указатели
===

В С++11 есть 4 *интеллектуальных указателя*: *std::auto_ptr*, *std::unique_ptr*, *std::shared_ptr* и *std::weak_ptr*.
*std::auto_ptr* пришёл из C++98 и является устаревшим. *std::unique_ptr* во всех смыслах лучше *std::auto_ptr*.

## 4.1 Используйте *std::unique_ptr* для управления ресурсами путём исключительного владения.

*std::unique* имеет тот же размер, что и обычный указатель, а для большинства операций выполняются такие же команды.

В процессе конструирование объект *std::unique+ptr* можно настроить для использование *пользовательских удалителей (custom deleters)*.

```cpp
class Investment {                     // Инвестиции
public:
    virtual ~Investment ();            // Важная часть дизайна
};
class Stock :
    public Investment { /* ... */ };   // Акции
class Bond :
    public Investment { /* ... */ };   // Облигации
class RealEstate :
    public Investment { /* ... */ };   // Недвижимость

auto delInvmt = [] (Investment* pInvestment)
    {
        makeLogEntry (pInvestment);
        delete pInvestment;
    }
    
template <typename... Ts>
auto makeInvestment (Ts&&... params)    // Фабричная функция (C++14)
{
    std::unique_ptr <Investment, decltype (delInvmt)> pInv (nullptr, delInvmt);
    if ( /* Stock */ )
    {
        pInv.reset (new Stock (std::forward <Ts> (params)...));
    }
    else if ( /* Bond */ )
    {
        pInv.reset (new Bond (std::forward <Ts> (params)...));
    }
    else if ( /* RealEstate */ )
    {
        pInv.reset (new RealEstate (std::forward <Ts> (params)...));
    }
    
    return pInv;
}
```

Как только в *std::unique_ptr* появляется пользовательские удалители, его размер увеличивается на указатель. Но это происходит не всегда, а когда указывается функция. В случае *функциональных объектов без состояний* (например, лямба-выражения без захватов), увеличение размера не происходит, поэтому разумно пользоваться в качестве пользовательских удалителей *лямба-выражениями*.

Благодаря тому, что *std::unique_ptr* имеет две разновидности: *std::unique_ptr <T>* и *std::unique_ptr <T[]>*, т.е. для объектов и массивов, то не возникает неопределённости на какую сущность указывает *std::unique_ptr*. Но использовать встроенные массивы разумно разве что для С-образного API.

*std::unique_ptr* - способ выражения исключительного владения на С++11. Но очень привлекательно то, что его можно легко и эффективно преобразовать в *std::shared_ptr*:  
```cpp
std::shared_ptr <Investment> sharedPointer = makeInvestment (args);
```

Благодаря этому *std::unique_ptr* очень хорошо подходит для фабричных функций, ведь последние не знают кто будет владеть объектом: один или совместно.

### <center>Следует запомнить</center>
* *std::unique_ptr* представляет собой маленький, быстрый, предназначенный только для перемещения интеллектуальный указатель для управления ресурсами с семантикой исключительного владения.
* По умолчанию освобождение ресурсов выполняется с помощью оператора *delete*, но могут применяться и *пользовательские удалители*. Удалители без состояний и указатели на функции в качестве удалителей увеличивают размеры объектов *std::unique_ptr*.
* Интеллектуальные указатели *std::unique_ptr* легко преобразуются в интеллектуальные указатели *std::shared_ptr*.







































