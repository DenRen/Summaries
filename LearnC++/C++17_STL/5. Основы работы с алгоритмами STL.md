# Глава 5. Основы работы с алгоритмами *STL*

## Копируем элементы из одних контейнеров в другие
```cpp
namespace std {
ostream& operator << (ostream& os, const pair <int, string>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}
}

int main () {
    vector <pair <int, string>> v {
        {1, "one"}, {2, "two"}, {3, "three"},
        {4, "four"}, {5, "five"}};
    map <int, string> m;
    
    copy_n (begin(v), 3, inserter (m, begin (m)));
    auto shell_it (ostream_iterator <pair <int, string>> {cout, ", "});
    copy (begin (m), end (m), shell_it);
    cout << cout;
    
    m.clear ();
    move (begin (v), end (v), inserter (m, begin (m)));
    copy (begin (m), end (m), shell_it);
    cout << cout;
    copy (begin (v), end (v), shell_it);
    cout << cout;
}
```
```bash
$ ./copying_items
(1, one), (2, two), (3, three),
(1, one), (2, two), (3, three), (4, four), (5, five),
(1, ), (2, ), (3, ), (4, ), (5, ),
```

#### Даже простая функция *std::copy* при непрерывности памяти не просто копирует элементы в цикле, а копирует их при помощи *memovoe*, что делает её очень быстрой. Всегда стоит пользоваться *STL* алгоритмами, если есть возможность. Они будут и читабельнее и **быстрее**.

## Сортируем контейнеры

* *std::sort*
* *std::is_sorted*
* *std::shuffle* - перемешивает контейнер
* *std::partial_sort* - принимает ещё один итератор, до него перемещает все самые маленькие элементы в отсортированном виде
* *std::partition*- все элементы удовлетворяющие предикату перемещаются в начало

## Удаляем конкретные элементы из контейнеров

* *std::remove*
* *std::replace*
* *std::remove_copy*
* *std::replace_copy*
* *std::copy_if*

```cpp
int main () {
    vector <int> v {1, 2, 3, 4, 5, 6};
    print (v);
    {
        // remove указывает на новый конец, он просто перемещает объекты
        const auto new_end (remove(begin(v), end(v), 2));
        v.erase(new_end, end(v));
    }
    print(v);

    {
        auto odd_number ([](int i) { return i % 2 != 0; });
        const auto new_end (
        remove_if(begin(v), end(v), odd_number));
        v.erase(new_end, end(v));
    }
    print(v);
    
    replace(begin(v), end(v), 4, 123);
    print(v);
    
    v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    vector<int> v2;
    vector<int> v3;
    
    auto odd_number ([](int i) { return i % 2 != 0; });
    auto even_number ([](int i) { return i % 2 == 0; });
    
    // Не копировать если
    remove_copy_if(begin(v), end(v),
    back_inserter(v2), odd_number);
    
    // Копировать если
    copy_if(begin(v), end(v),
    back_inserter(v3), even_number);
    
    print(v2);
    print(v3);
}
```
```bash
$ ./removing_items_from_containers
1, 2, 3, 4, 5, 6,
1, 3, 4, 5, 6,
4, 6,
123, 6,
2, 4, 6, 8, 10,
2, 4, 6, 8, 10,
```

## Преобразуем содержимое контейнеров

* *std::transform*
```cpp
// ...
transform(begin(v), end(v),
          ostream_iterator<int>{cout, ", "},
          [] (int i) { return i * i; });
cout << cout;

// ...
auto int_to_string ([] (int i) {
    stringstream ss;
    ss << i << "^2 = " << i * i;
    return ss.str ();
});
vector <string> vs;
transform (begin (v), end (v), back_inserter (vs), 
           int_to_string);
```

## Выполняем поиск элементов в упорядоченных и неупорядоченных векторах
* *std::find* - простой линейный поиск
* *std::find_if* - линейный поиск, и использованием предиката
* *std::binary_search* - выполняет бинарный поиск элемент и возвращает *true*, если нашёл
* *std::lower_bound*- бин. поиск первого элемента, чьё значение не меньше значения для сравнения
* *std::upper_bound*- бин. поиск первого элемента, чьё значение больше значения для сравнения
* *std::equal_range* - бинарный поиск. Возвращает пару: результат *std::lower_bound* и *std::upper_bound*






































































































































