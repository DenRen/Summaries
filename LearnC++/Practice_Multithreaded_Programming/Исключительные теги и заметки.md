Исключительные теги и заметки
===

## Глава 1. Здравствуй, мир конкурентности в C++!

* **Конкурентность** - это переключение задач
* **Пареллелизм** - это использование железа для повышения производительности

## Глава 2. Управление потоками

* *std::thread*
```cpp
std::thread t {func};
t.join ();
t.detach ();
t.joinable () == true;
std::thread::hardware_concurrency ();
std::this_thread::get_id ();
std::thread t2;
t2 = std::move (t);
```
* *joinable_thread*

### Глава 3. Совместное использование данных несколькими потоками
* *std::mutex mutex;*
* *mutex.lock ();* or *mutex.unlock ()*
* *mutex.try_lock ()*
* *std::lock_guard guard {mutex};*
* *std::lock_guard guard {mutex, std::adopt_lock};*
* *std::scoped_lock guard {mutex};*
* *class threadsafe_stack*
* *std::lock (mutex1, mutex2); std::lock_guard g1 (mutex1); std::lock_guard g2 (mutex2);*
* *std::scoped_lock guard (mutex1, mutex2);*
* *class hierarchical_mutex*
* *std::unique_lock uguard {mutex, std::defer_lock};*
* *uguard.owns_lock (); // Flag*
* Степень детализации блокировок
* *std::call_once*, *std::once_flag*, *std::call_once (init_flag, &X::init_conn, this)*
* *std::shared_mutex*, *std::shared_timed_mutex*
* *std::shared_lock <std::shared_mutex>*
* *std::recursive_mutex*

### Глава 4. Синхронизация конкурентных операций
* *std::condition_variable*, *std::condition_variable_any*
* *notify_one (), notify_all (), wait (mutex, [] { return x > 5; })*
* *mutable std::mutex*
* *std::future<>*, *std::shared_future<>*
* *std::async*
* *std::package_task*, *get_future ()*
* *std::promise*, *set_value ()*, *set_exception ()*
* *std::future_error*, *std::future_errc::broken_promise*
* *std::current_exception ()*, *std::make_exception_ptr (std::logic_error ("Error here")*
* *std::shared_future*
* *get_future ().share ()*
* *wait_for x2, wait_until x2*
* ---
* *std::chrono::system_clock::now ()*, *typedef typepoint*
* **typedef period:*** *std::ratio <1, 25>*, *std::ratio <5, 2>*
* *std::chrono::duration <short, std::ratio <60, 1>*
* *std::chrono_literals*
* *std::chrono::duration_cast <std::chrono_seconds> ()*
* *std::chrono::millisecnods (1234).count ()*
* *std::future_status::ready*
* *std::cv_status::timeout*
* *sleep_for*, *sleep_until*
* *std::timed_mutex*, *std::recursive_timed_mutex*, *try_lock_for*, *try_lock_until*
* ---
* *std::experimental::future fut; fut,then (find_the_question)*
* *std::experimental::when_all*, *std:experimentaL::what_any*
* *std::experimental::latch*, *count_down*, *wait*, *is_ready*, *count_down_and_wait*
* *std::experimental::barrier / flex_barrier*, *arrive_and_wait*, *arrive_and_drop*

### Глава 5. *Модель памяти C++* и операции над атомарными типами











































