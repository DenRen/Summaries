7\.  Параллельные вычисления
========================

### 7.1 Предпочитайте программирование на основе *задач* программированию на основе *потоков*.

Есть два варианта запустить *doAsnycWork* асинхронно:
```cpp
int doAsyncWork ();

std::thread (doAsyncWork);    // Поток

auto fut = std::async (doAsyncWork); // fut = future
```
Преимущества *std::async*:
* Даёт возвращающее значение в вызывающий код
* Есть доступ к исключению, которое бросила функция (в потоках будет *std::terminate*)
* Решает проблему превышения подписки

Бывают ситуации, когда применение *потоков* является более подходящим:
* Вам нужен доступ к *API*, лежащий в основе реализации потоков (*pthreads* или *Windows Threads*)
* Вам требуется возможность оптимизации потоков в вашем приложении
* Вам требуется реализовать поточную технологию, выходящую за рамки *API* параллельных вычислений *C++*

### <center>Следует запомнить</center>
* API *std::thread* не предлагает способа непосредственного получения возвращаемых значений из асинхронно выполняемых функций, и, если такие функции генерируют исключения, программа завершается.
* Программирование на основе потоков требует управления вручную исчерпанием потоков, превышением подписки, балансом загрузки и адаптацией к новым платформам.
* Программирование на основе задач с помощью *std::async* со стратегией запуска по умолчанию решает большинство перечисленных проблем вместо вас.

### 7.2 Если важна асинхронность, указывайте std::launch::async
* **Стратегия** *std::launch:async* означает, что* func* должна выполнятся асинхронно, т.е. в другом потоке
* **Стратегия** *std::launch::deferref* означает, что *func* может выполняться только тогда, когда для *фьючерса*, возвращённого *std::async*, вызывается функция-член *get* или *wait*, т.е. выполнение *func* *откладывается* до тех пор, пока не будет выполнен такой вызов. Когда вызываются функции-члены *get* или *wait*, функция *func* выполняется синхронно, т.е. вызывающая функция блокируется до тех пор, пока *func* не завершит работу. Если не вызывается ни *get*, ни *wait*, *func* не выполняется. 

Два приведённых вызова имеют один и тот же смысл:
```cpp
auto fut1 = std::async (func);                        // Выполнение func со стратегиейпо умолчанию

auto fut2 = std::async (std::launch::async |          // Выполнение func асинхронное и отложенное
                         std::launch::deferred,
                         func);
```

У стратегии запуска по умолчанию есть интересные последствия. Для потока *t*, выполняющую приведённую ниже инструкцию, справедливы следующие утверждения:
```cpp
auto fut = std::async (func); // Выполнение func со стратегией запуска по умолчанию
```
* **Невозможно предсказать, будет ли *func* выполняться параллельно с *t***, поскольку выполнение *func* может быть отложено планировщиком.
* **Невозможно предсказать, будет ли *func* выполняться потоком, отличным о того, в котором вызываются функции-члены *get* или *wait* объекта *fut***. Если этот поток - t, отсюда вытекает невозможность предсказать, будет ли *func* выполняться потоком, отличным от *t*.
* **Может быть невозможно предсказать, будет ли *func* выполнена вообще**, поскольку может оказаться невозможность гарантировать, что функции-члены *get* или *wait* объекта *fut* будут вызваны на всех путях выполнения программы.








































