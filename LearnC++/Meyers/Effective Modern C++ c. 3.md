Переход к современному C++
===

## 3.1 Различие между {} и  () при создании объектов

С++ трактует следующие выражении одинаково:
```cpp
int z { 0 };    // То же 
int z = { 0 };  // самое
```

Для устранения путаницы из-за нескольких синтаксисов инициализации и решения проблемы охвата всех сценариев инициализации C++11 вводит *унифицированную инициализацию (uniform initialization)*: единый синтаксис инициализации, который может, как минимум концептуально, использоваться везде и выражать всё. Он основан на фигурных скобках: *"фигурная инициализация" (braced initialization)*.

Примеры:
```cpp
std::vector <int> v { 1, 3, 5 };
``` 

```cpp
class Widget {
...
private:
    int x { 0 };  // Ок, значение по умолчанию равно 0
    int y = 0;    // Тоже ок
    int z (0);    // Ошибка!
};
```

```cpp
std::atomic <int> ail0 { 0 }; // Ок
std::atomic <int> ail1 (0);   // Ок
std::atomic <int> ail2 = 0;   // Ошибка!
```

Т.е. из трёх способов обозначения выражений инициализации только фигурные скобки могут использоваться везде.

Новая возможность фигурной инициализации заключается в том, что она запрещает неявные *сужающие преобразования* среди встроенных типов:
```cpp
double x = 0, y = 0, z = 0;

int sum { x + y + z }; // Ошибка! Сумма double не выражется с помощью int 
```

Правда в данном случае gcc кинет Warning, но не более.

Инициализация с использование круглых скобок и знака равенства не выполняет проверку сужающего преобразования:

```cpp
int sum1 (x + y + z);
int sum2 = x + y + z;
```  

Фигурные скобки решают проблему *наиболее неприятного анализа*:
```cpp
Widget w0 (10);   // Вызов конструктора
Widget w1 ();     // Объявление функции w1
Widget w2 {};     // Конструктор по умолчанию
```











































