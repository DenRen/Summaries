# Глава 1. Новые возможности C++ 17

## Декомпозиция для распаковки возвращаемых значений

* Декомпозиция std::tuple
```cpp
std::tuple <std::string, unsigned, std::string>
getUserData (std::size_t id);

const auto[name, age, city] = getUserData (5);
```

* Декмпозиця структуры
```cpp
struct employee {
    unsigned id_;
    std::string name_;
    std::string role_;
    unsigned salary_;
};

int main () {
    std::vector<employee> employees {/* Инициализируется в другом месте */};
    for (const auto &[id, name, role, salary] : employees) {
        std::cout << "Name: " << name << ", "
                  << "Role: " << role << ", "
                  << "Salary: " << salary << std::endl;
    }
}
```

### Как это работает
```cpp   
    auto [var1, var2, ...] = <выражение пары, кортежа, структуры или массива>
```

* Кол-во переменных *var1*, *var2*, *...* должно точно совпадать с кол-вом переменных в выражении, в отношении которого выполняется присваивание.
* Элементом *<выражение пары, кортежа, структуры или массива>* должен быть один из следующих объектов:
   * *std::pair*
   * *std::tuple*
   * *Структура.* Все его члены должны быть *нестатическими* и определёнными в *одном базовом классе*.
   * *Массив* фиксированного размера

 ### Не забывайте, что можно использовать ссылки: *const auto& [vars...]*

## Ограничиваем область видимости переменных в выражениях *if* и *switch*

### По сути, это просто создание переменной внутри *if* или *switch*
```cpp
if (auto iter {character_map.find ("C++17")}; iter != character_map.end ()) {
    // *iter корректен
} else {
    // Не найдено
}

// Здесь iter не существует
```

Аналогично *switch*
```cpp
switch (char c {getchar()}; c) {
    case 'a': move_left(); break;
    case 's': move_back(); break;
    case 'w': move_fwd(); break;
    case 'd': move_right(); break;
    case 'q': quit_game(); break;

    case '0'...'9': select_tool('0' - c); break;
    
    default:
        std::cerr << "Invalid input: " << c << std::endl;
}
```

### Как это работает
```cpp
if (auto var {init_value}; condition) {
    // var доступен
} else {
    // var доступен
}
// var не доступен

switch (auto var {init_value}; var) {
    case 1: ... // var доступен
    case 2: ... // var доступен
      ...
}
// var не доступен
```

### Отличные применения
```cpp
if (std::lock_guard <std::mutex> lg {my_mutex}; some_condition) {
    // Делаем что-нибудь
}

if (auto shared_pointer {weak_pointer.lock ()}; shared_pointer != nullptr) {
    // Да, общий объект ещё существует
} else {
    // ...
}

// Удобная обработка ошибок из Си
if (DWORD exit_code; GetExitCodeProcess (process_handle, &exit_code)) {
    std::cout << "Exit code of process was: " << exit_code << std::endl;
}
```

## Новые правила инициализатора с фигурными скобками

```cpp
auto v {1};           // v - int
auto w {1,2}          // Error! (Нововведение)

auto x = {1};         // std::initializer_list <int>
auto x = {1, 2};      // std::initializer_list <int, int>
auto x = {1, 2, 3.0}; // Error: нельзя вывести тип
```

### Основные правила:
* в конструкции *auto var_name {one_element};* переменная *var_name* будет иметь тот же тип, что и *one_element*
* конструкция *auto var_name {element1, element2, ...};* недействительна и не будет скомпилирована
* конструкция *auto var_name = {element1, element2, ...};* будет иметь тип *std::initializer_list <T>*, где *T* - тип всех элементов списка.

### Важно: это нововведение может вызвать проблемы с переносимостью

## Разрешаем конструктору автоматически выводить полученный тип класса шаблона

```cpp
std::tuple my_typle {1, 2.0, "C++17"}; // std::tuple <int, double, const char*>
```

Раньше такого можно было добиться только при помощи специальных функций: *std::nake_tuple*.

### Но не всегда стоит полагаться на *неявное выведение типа шаблона*
Пример:
```cpp
template <typename T>
struct sum {
    T value_:
    
    template <typename... Ts>
    sum (Ts&&... values) :
        value_ {(values + ...)}
    {}
};
```

Но какой тип должен выводиться у T? Для этого нужно явно задать правила:
```cpp
template <typename... Ts>
sum (Ts&&... values) -> sum <std::common_type_t <Ts...>>;
```

## Упрощаем принятие решений во время компиляции с помощью *constexpr-if*

```cpp
template <typename T>
class addable {
    T value_;
    
public:
    addable (T value) :
        value_ (value)
    {}
    
    template <typename U>
    add (U value) const {
        if constexpr (std::is_same_v <T, std::vector <U>) {
            auto copy_vector {value_}; // Создаём новый вектор
            for (auto& item : copy_vector) {
                item += value_;
            }
            
            return copy_vector;
        } else {
            return value + value_;
        }
    }
};
```

### Как это работает
```cpp
if constexpr (a) {
    // Для данного условия компилирется только эта часть
} else if constexpr (b) {
    // Для данного условия компилирется только эта часть
} else {
    // Для данного условия компилирется только эта часть
}
```

**Ветвления конструкции *constexpr-if* должны быть *синтаксически правильными*, но неиспользованные ветви не обязаны быть *семантически корректными*.**

## Подключаем библиотеки с помощью встраиваемых переменных

Мы хотим предоставить доступ к статическому полю класса через глобально доступный элемент класса, до *C++17* это было сделать невозможно.
1. До *C++17* данный код в нескольких единицах трансляции приведёт к появлению символов, определённых дважды
```cpp
// .hpp
class process_monitor {
public:
    static const std::string standart_string {
        return "some static globally available string";
    };
};

process_monitor global_process_monitor;
```
2. Начиная с *C++17* добавляем *inline* и **всё работает!**
```cpp
// .hpp
class process_monitor {
public:
    static inline const std::string standart_string {
        return "some static globally available string";
    };
};

inline process_monitor global_process_monitor;
```

Компоновщик выбирает встраиваемые (*inline*) символы просто беря первый попавшийся. На программиста возложена *ответственность* за то, чтобы все одинаковые встраиваемые символы были определены абсолютно идентично.

## Реализуем вспомогательные функции с помощью выражений свёртки

Чтобы применить оператор ко всем значениям пакета, не забудем *взять выражение в скобки*:
```cpp
template <typename... Ts>
auto sum (Ts... ts) {
    return (ts + ...);
}
```
* *values* **op** *...* - правая свёртка
* *...* **op** *values* - левая свёртка

Примеры:
* *values* **+** *...* - ((((1+2) + 3) + 4) +5
* *...* **+** *values* - 1 + (2 + (3 + 4 + 5)))

### Также можно ограничивать свёртку (*бинарная* свёртка)
```cpp
template <typename... Ts>
auto sum (Ts... args) {
    return (args + ... + 0);
}

template <typename... Ts>
auto product (Ts... args) {
    return (args * ... * 1);
}
```
Также допустимы *(0 + ... + args)*.

### Пример с диапазонами
Как насчет функции, которая определяет с диапазоне количество значений, передаваемых в пакете параметров с переменной длиной:
```cpp
template <typename R, typename... Ts>
auto matches (const R& range, Ts ... values) {
    return (std::count (std::begin (range), std::end (range), ts) + ...);
}
```

### Проверка успешности вставки нескольких элементов в множество
```cpp
template <typename T, typename ... Ts>
bool insert_all (T &set, Ts ... ts) {
return (set.insert (ts).second && ...);
}

// Объяснение: std::pair<iterator, bool> insert(const value_type& value);
```

### Проверка попадания всех параметров в заданный диапазон
```cpp
template <typename T, typename... Ts>
bool within (T min, T max, Ts... values) {
    return ((min <= values <= max) && ...);
}
```





































