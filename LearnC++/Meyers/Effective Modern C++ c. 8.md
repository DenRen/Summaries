8\. Тонкости
===

Решение о применении *общего метода* (*передача по значению*) и *общей возможности* (*размещение (emplacement)*) зависит от такого большого количества факторов, что лучший совет для них сводится к *рассмотрению* возможности их применения.

## 8.1 Рассмотрите передачу по значению для копируемых параметров, которые легко перемещаются и всегда копируются

Копирование параметра в общем случае означет его использование как источника операций копирования и перемещения.

Если вы хотите добавить функцию, которая принимает, например, *std::string*, то вероятно вы захотите использовать все преимущества языка и использовать либо *перегрузку*, либо *применение универсальной ссылки*, либо *передачу по значению*. Напрмер:
```cpp
class Widget {                                // Перегрузка
public:

    void addName (const std::string& name) {
        names.push_back (name);
    }    
    
    void addName (std::string&& name) {
        names.push_back (std::move (name));
    }

private:
    std::vector <std::string> names;
};
```

```cpp
class Widget {                                // Применение универсальной ссылки
public:
    
    template <typename T>
    void addName (T&& name) {
        names.push_back (std::forward <T> (name));
    }

private:
    std::vector <std::string> names;
};
```

```cpp
class Widget {                                // Передача по значению
public:
    
    void addName (std::string name) {
        names.push_back (std::move (name));
    }

private:
    std::vector <std::string> names;
};
```

Далее просто считаем плюсы и минусы каждого варианта: кол-во вызовов, копирований, перемещений, простота и безопасность написания и т.д. Выбор можте даже зависить от того типа, с которым вы работаете. Иногда нужно просто *рассмотреть* варианты, включая передачу по значению. Есть много ньюансов: функция может принимать только rvalue значения, либо же наоборот только lvalue, тогда отпадает необходимость в реализации смежной функции.

Но есть ещё и ситуации, когда параметр копируется с использованием присваивания:
```cpp
class Password {
public:
    explicit Password (std::string pwd) :
        text (std::move (pwd))
    {}
    
    void changeTo (std::string newPwd) {
        text = std::move (newPwd);
    }

private:
    std::string text;
};
```

В *changeTo* слишком много работы с  динамической памятью: создаине для *newPwd и удаление для *text*. Это на порядки больше, чем просто перемещающая операция! (Только если *text.lenght () >= newPwd.lenght ()*)

Но всё равно мы видим, что передача по значению всегда дороже, чем иные подходы.

Анализ стоимости передачи по значению состоит в стратегии *презумпции виновности* (*виновен, пока не доказано иное*)

Ни в коем случае нельзя передавать по значению в функцию, которая принимает базовый класс и все его производные! Будет теряться информация о производном классе! (Здесь вступает в силу *проблема срезки*)

### <center>Следует запомнить</center>
* Для копируемых и легко перемещаемых параметров, которые всегда копируются, передача по значению может быть почти столь же эффективной, как и передача по ссылке, более простой в реализации и генерировать меньший объектный код.
* Для lvalue-аргументов передача по ссылке (например, копирующее конструирование), за которой следует перемещающее присваивание, может оказаться существенно более дорогостоящией, чем передача по ссылке с последующем копирующем присваиванием.
* Передача по значению подвержена проблеме срезки, так что обычно не годится для типов параметров базового класса.

## 8.2 Рассмотрите применение размещения вместо вставки

Давайте рассмотрим класс *std::vector*, в котором перегружена функция *std::vector::push_back* для *lvalue* и *rvalue*. Передадим в неё не *std::string*, а *строковый литерал*:
```cpp
std::vector <std::string> vs;
vs.push_back ("xyzzy");
```

Если приглядется, то для заядлых программистом, требующих максимальной эффективности, этот код может показаться медленным. Дело в том, что объект в *std::vector* создаётся не из строкового литерала, а из объекта *std::string*, который был создан из строкового литерала. Вот что произошло:
1. Создаётся временный объект *std::string temp ("xyzyz")*
2. Конструируется через перемещение объект в векторе
3. Вызывается деструктор во временном объекте

Не слишком ли много действий для простого создания элемента вектора из строки?

Самый простой способ добиться в данном примере максимальной эффективности - это не использовать *push_back*. Нам нужна функция emplace_back:
```cpp
vs.emplace_back ("xyzzy");
```

Эта функция-член делает именно то, что нам нужно:использует переданный аргумент для конструирования *std::string* непосредственно внутри *std::vector*. *emplace_back* использует прямую передачу.

Так почему же не использовать *функции размещения* постоянно? Они же эффективнее, чем *функции вставки*? Дело в том, что это не всегда так и зависит от большого количества факторов.

Есть эврестическое правила, если которые выполняются, то почти наверняка размещение будет опережать вставку:
 * Добавляемое значение конструируется в контейнере, а не присваивается.
 * Типы передаваемых объектов отличаются от типа, хранящегося в контейнере.
 * Маловероятно, что контейнер отвергнет новое значение как дубликат.

Теперь рассмотрим следующий код:
```cpp
std::list <std::shared_ptr <Widget>> ptrs;

void killWidget (Widget* widget);

ptrs.push_back (std::shared_ptr <Widget> (new Widget, killWidget));
```
Аналогично:
```cpp
ptrs.push_back ({ new Widget, killWidget });
```

 Они совершенно эквивалентны и безопасны относительно исключений. Здесь всё отлично.

 Но что, если мы применим размещение:

```cpp
ptrs.emplace_back (new Widget, killWidget);
```

Если после создания аргументов вектор запросит память, но её не будет, то он бросит исключение. Это приведёт к утечке Widget, потому что ничего больше на него не указывает!

Безопасным будет вынесение создание и передача как *rvalue*:
```cpp
std::shared_ptr <Widget> spw (new Widget, killWidget);
ptrs.emplace_back (std::move (spw));
```

Также стоит обратить внимание на функции размещения и взаимодействия их с *explicit* конструкторами:
```cpp
std::vector <std::regex> regexes;

regexes.emplace_back (nullptr); // Компилируется
```

Это, конечно, неопределённое поведение. Дело в том, что конструктор *std::regex* объявлен как *explicit*, как следствие:
```cpp
std::regex r = nullptr;       // Ошибка! Не компилируется!
regex.push_back (nullptr);    // Ошибка! Не компилируется!
```
Но предыдущий пример компилировался потому, что мы передавали не объект *std::regex*, а аргументы конструктора объекта *std::regex*. **Это не рассматривается как запрос неявного преобразования!***

Два похожих синтаксиса инициализации (*инициализацией копированием* (*copy initialization*) и *прямой инициализацией* (*direct initialization*)) дают очень разные результаты:
```cpp
std::regex r1 = nullptr;    // Ошибка! Не компилируется!
std::regex r2 (nullptr);    // Компилируется!
```

Дело в том, что инициализация копированием не может использовать конструкторы, объявленные как *explicit*, хотя прямая инициализация может.

### <center>Следует запомнить</center>
* В принципе, функции размещения должны иногда быть более эффективными, чем соответствующие функции вставки, и не должны быть менее эффективными.
* На практике они чаще всего более быстрые, когда (1) когда добавляемое значение конструируется в контейнере, а не присваивается; (2) типы передаваемых аргументов отличаются от типа, хранящегося в контейнере; и (3) контейнер не отвергает дубликаты уже содержащихся в нём значений.
* Функции рахмещения могут выполнять преобразования типов, отвергаемые функциями вставки. 






























