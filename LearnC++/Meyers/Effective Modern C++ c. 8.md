8\. Тонкости (no end)
===

Решение о применении *общего метода* (*передача по значению*) и *общей возможности* (*размещение (emplacement)*) зависит от такого большого количества факторов, что лучший совет для них сводится к *рассмотрению* возможности их применения.

## 8.1 Рассмотрите передачу по значению для копируемых параметров, которые легко перемещаются и всегда копируются

Копирование параметра в общем случае означет его использование как источника операций копирования и перемещения.

Если вы хотите добавить функцию, которая принимает, например, *std::string*, то вероятно вы захотите использовать все преимущества языка и использовать либо *перегрузку*, либо *применение универсальной ссылки*, либо *передачу по значению*. Напрмер:
```cpp
class Widget {                                // Перегрузка
public:

    void addName (const std::string& name) {
        names.push_back (name);
    }    
    
    void addName (std::string&& name) {
        names.push_back (std::move (name));
    }

private:
    std::vector <std::string> names;
};
```

```cpp
class Widget {                                // Применение универсальной ссылки
public:
    
    template <typename T>
    void addName (T&& name) {
        names.push_back (std::forward <T> (name));
    }

private:
    std::vector <std::string> names;
};
```

```cpp
class Widget {                                // Передача по значению
public:
    
    void addName (std::string name) {
        names.push_back (std::move (name));
    }

private:
    std::vector <std::string> names;
};
```

Далее просто считаем плюсы и минусы каждого варианта: кол-во вызовов, копирований, перемещений, простота и безопасность написания и т.д. Выбор можте даже зависить от того типа, с которым вы работаете. Иногда нужно просто *рассмотреть* варианты, включая передачу по значению. Есть много ньюансов: функция может принимать только rvalue значения, либо же наоборот только lvalue, тогда отпадает необходимость в реализации смежной функции.

Но есть ещё и ситуации, когда параметр копируется с использованием присваивания:
```cpp
class Password {
public:
    explicit Password (std::string pwd) :
        text (std::move (pwd))
    {}
    
    void changeTo (std::string newPwd) {
        text = std::move (newPwd);
    }

private:
    std::string text;
};
```

В *changeTo* слишком много работы с  динамической памятью: создаине для *newPwd и удаление для *text*. Это на порядки больше, чем просто перемещающая операция! (Только если *text.lenght () >= newPwd.lenght ()*)

Но всё равно мы видим, что передача по значению всегда дороже, чем иные подходы.

Анализ стоимости передачи по значению состоит в стратегии *презумпции виновности* (*виновен, пока не доказано иное*)

Ни в коем случае нельзя передавать по значению в функцию, которая принимает базовый класс и все его производные! Будет теряться информация о производном классе! (Здесь вступает в силу *проблема срезки*)

### <center>Следует запомнить</center>
* Для копируемых и легко перемещаемых параметров, которые всегда копируются, передача по значению может быть почти столь же эффективной, как и передача по ссылке, более простой в реализации и генерировать меньший объектный код.
* Для lvalue-аргументов передача по ссылке (например, копирующее конструирование), за которой следует перемещающее присваивание, может оказаться существенно более дорогостоящией, чем передача по ссылке с последующем копирующем присваиванием.
* Передача по значению подвержена проблеме срезки, так что обычно не годится для типов параметров базового класса.














































