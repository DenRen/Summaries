Контейнеры STL
===

### Примеры контейнеров:
* Непрерывные хранилища
    * *std::array*
    * *std::vector*
* Хранение списков
    * *std::list*
    * *std::forward_list*
* Деревья поиска
    * *std::set*
    * *std::map*
    * *std::multiset*
    * *std::multimap*
* Хеш-таблицы
    * *std::unordered_set*
    * *std::unordered_map*
    * *std::unordered_multiset*
    * *std::unordered_multimap*
* Адаптеры контейнеров
    * *std::stack*
    * *std::queue*
    * *std::priority_queue*

### Для удобства сразу введём перегрузку оператора *<<* для *std::vector*
```cpp
template <typename T>
std::ostream& operator << (std::ostream& os,
                           const std::vector <T>& vec) {
    auto begin = vec.cbegin ();
    const auto end = vec.cend ();
    if (begin == end) {
        return os;
    }
    
    os << *begin++;
    while (begin != end) {
        os << ", " << *begin++;
    }

    return os;
} // operator << (std::ostream& os, const std::vector <T>& vec)
```

## Используем идиому erase-remove для контейнера *std::vector*
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

templa

int main () {
    std::vector <int> vec {1, 2, 3, 2, 5, 2, 6, 2, 4, 8};
    const auto new_end (std::remove (std::begin (vec), std::end (vec), 2));
    
    std::cout << vec << std::endl;

    // Delete a set numbers
    const auto odd ([] (int i) { return i % 2 == 0l; });
    vec.erase (std::remove_if (std::begin (vec), std::end (vec), odd), std::end (vec));
    
    // Мы удалили чётные элементы, но ёмкость вектора осталась преждней. Изменим её
    vec.shrink_to_fit ();
    
    std::cout << vec << std::endl;
}
```

В итоге получим результат:
```bash
$ ./main
1, 3, 5, 6, 4, 8
6, 4, 8
```

### Как это работает
![](./imgs/2.1.png)

## Удаляем элементы из неотсортированного объекта класса std::vector за время O(1)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

template <typename T>
void quick_remove_at (std::vector<T> &vec,
                      std::size_t idx) {
    if (idx < vec.size ()) {
        vec[idx] = std::move (vec.back ());
        vec.pop_back();
    }
}

int main () {
    std::vector <int> vec {123, 456, 789, 100, 200};
    
    quick_remove_at (vec, 2);
    std::cout << vec << std::endl;
}
```

Также можно это реализовать и через интерфейс итераторов:
```cpp
template <typename T>
void quick_remove_at (std::vector<T> &vec,
                      typename std::vector<T>::iterator it) {
    if (it != std::end (vec)) {
        *it = std::move (vec.back ());
        vec.pop_back ();
    }
}
```

Результат:
```bash
$ ./main
123, 456, 200, 100
100, 456, 200
```

### Как это работает
![](./imgs/2.2.png)

## Получаем доступ к экземплярам класса *std::vector* быстрым или безопасным способом

* *Оператор []* - не делает проверку на выход за границы
* *Метод at ()* - делает проверку на выход за границы (при ошибке бросает исключение *std::out_of_range*)

## Сохраняем сортировку экземпляров класса *std::vector*
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <cassert>

std::template <typename T>
void insert_sorted (std::vector <T>& vec,
                    const T& value) {
    const auto insert_pos {std::lower_bound (std::begin (vec), std::end (vec), value)};
    vec.insert (insert_pos, value);
}

int main () {
    std::vector <std::string> vec {"some", "random", "words",
                                   "without", "order", "aaa",
                                   "yyy"};

    assert(false == std::is_sorted (std::begin (vec), std::end (vec)));
    std::sort (std::begin (vec), std::end (vec));
    assert(true == std::is_sorted (std::begin (vec), std::end (vec)));
    
    insert_sorted(v, "foobar");
    insert_sorted(v, "zzz");
    
    std::cout << vec << std::endl;
}    
```

```bash
$ ./main
aaa foobar order random some without words yyy zzz
```

Мы можем сделать эту функцию более универсальной: для *std::set* , *std::deque* , *std::list* и т. д!
```cpp
template <typename C, typename T>
void insert_sorted (C &c, const T &item) {
    const auto insert_pos {std::lower_bound (std::begin (c), std::end c), item)};
    c.insert (insert_pos, item);
}
```

## Вставляем элементы в контейнер *std::map* эффективно и в соответствии с условиями

Здесь достаточно самого важного только отрывка из примера, которые демонстрирует метод *try_emplace*:
```cpp
struct billionaire {
    string n    ame;
    double dollars;
    string country;
};

int main () {
    std::list <billionaire> billionaires { /* ... */ };
    std::map <std::string, std::pair <const billionaire, size_t>> m;
    
    for (const auto &b : billionaires) {
        auto [iterator, success] = m.try_emplace (b.country, b, 1);
        if (!success) {
            iterator->second.second += 1;
        }
    }
}
```

### Важно то, что *try_emplace* не будет создавать объект перед попыткой его вставить. *insert* и *emplace* так не могут.

## Исследуем **новую** семантику подсказок для вставки элементов с помощью метода std::map::insert
Мы можем подсказать *std::map* куда должен вставиться элемент, передав итератор на следующий за вставленным элемент.
#### Правильная подсказка будет указывать на существующий элемент, чье значение превышает значение вставляемого элемента, чтобы новый элемент занял позицию прямо перед ней.
```cpp
#include <iostream>
#include <map>
#include <string>

int main () {
    std::map <std::string, std::size_t> m {{"b", 1}, {"c", 2}, {"d", 3}};
    
    auto insert_it {std::end (m)};
    for (const auto& s : {"z", "y", "x", "w"}) {
        insert_it = m.insert (insert_it, {s, 1});
    }
    
    // Демонстраци того, как НЕ нужно подсказывать
    m.insert (std::end (m), {"a", 1});
    
    for (const auto& [key, value] : m) {
        std::cout << "\"" << key << "\": " << value << ", ";
    }
    std::cout << '\n';
}
```

```bash
$ ./main
"a": 1, "b": 1, "c": 2, "d": 3, "w": 1, "x": 1, "y": 1, "z": 1,
```

#### Стоит не забывать, что даже с правильной подсказкой, после вставки может произойти *перебалансировка* дерева.
![](./imgs/2.3.png)

## Эффективно изменяем ключи элементов *std::map*
















