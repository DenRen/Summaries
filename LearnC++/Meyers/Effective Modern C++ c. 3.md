Переход к современному C++
===

## 3.1 Различие между {} и  () при создании объектов

С++ трактует следующие выражении одинаково:
```cpp
int z { 0 };    // То же 
int z = { 0 };  // самое
```

Для устранения путаницы из-за нескольких синтаксисов инициализации и решения проблемы охвата всех сценариев инициализации C++11 вводит *унифицированную инициализацию (uniform initialization)*: единый синтаксис инициализации, который может, как минимум концептуально, использоваться везде и выражать всё. Он основан на фигурных скобках: *"фигурная инициализация" (braced initialization)*.

Примеры:
```cpp
std::vector <int> v { 1, 3, 5 };
``` 

```cpp
class Widget {
...
private:
    int x { 0 };  // Ок, значение по умолчанию равно 0
    int y = 0;    // Тоже ок
    int z (0);    // Ошибка!
};
```

```cpp
std::atomic <int> ail0 { 0 }; // Ок
std::atomic <int> ail1 (0);   // Ок
std::atomic <int> ail2 = 0;   // Ошибка!
```

Т.е. из трёх способов обозначения выражений инициализации только фигурные скобки могут использоваться везде.

Новая возможность фигурной инициализации заключается в том, что она запрещает неявные *сужающие преобразования* среди встроенных типов:
```cpp
double x = 0, y = 0, z = 0;

int sum { x + y + z }; // Ошибка! Сумма double не выражется с помощью int 
```

Правда в данном случае gcc кинет Warning, но не более.

Инициализация с использование круглых скобок и знака равенства не выполняет проверку сужающего преобразования:

```cpp
int sum1 (x + y + z);
int sum2 = x + y + z;
```  

Фигурные скобки решают проблему *наиболее неприятного анализа*:
```cpp
Widget w0 (10);   // Вызов конструктора
Widget w1 ();     // Объявление функции w1
Widget w2 {};     // Конструктор по умолчанию
```

Однако не забываем, про *std::initializer_list* при *auto {}*.

Без std::initializer_list:
```cpp
class Widget {
public:
    // Конструкторы без std::initializer_list
    Widget (int i, bool b);
    Widget (int i, double d);
};

Widget w0 (10, true);    // Вызов первого конструктора
Widget w1 {10, true};    // Вызов первого конструктора    
Widget w2 (10, 3.14);    // Вызов второго конструктора
Widget w3 {10, 3.14};    // Вызов второго конструктора
```

С std::initializer_list:
```cpp
class Widget {
public:
    Widget (int i, bool b);    // Как и ранее
    Widget (int i, double d);  // Как и ранее
    
    Widget (std::initializer_list <long double> i1); // Добавлен
};

Widget w0 (10, true);    // Вызов первого конструктора
Widget w1 {10, true};    // Вызов третьего конструктора (10, true -> long double)   
Widget w2 (10, 3.14);    // Вызов второго конструктора
Widget w3 {10, 3.14};    // Вызов третьего конструктора (10, 3.14 -> long double)
```

Пример с копированием и перемещением:
```cpp
class Widget {
public:
    Widget (int i, bool b);    // Как и ранее
    Widget (int i, double d);  // Как и ранее
    
    operator float () const;   // Преобразование во float
};

Widget w4 (w3);                // Копирующий конструктор
Widget w5 {w3};                // Конструктора с std::initializer_list
                               // (w3 преобр. в float, а float преобр. в long double)   
Widget w6 (std::move (w3));    // Перемещающий конструктор
Widget w7 {std::move (w3)};    // Аналогично w5
```

Мощный пример. Присмотритесь к *bool*. Тут происходит сужение в фигурных скобках, что запрещено C++:
```cpp
class Widget {
public:
    Widget (int i, bool b);    // Как и ранее
    Widget (int i, double d);  // Как и ранее
    
    Widget (std::initializer_list <bool> (i)); // Теперь тип элемента - bool
    
    // Нет функций неявного преобразования
};

Widget w (10, 3.14);    // Ошибка! Требуется сужающее преобразование
```

Тут int и double *можно было* неявно преобразовать в bool, но тогда это было бы сужающее преобразование.

Но если мы сделаем так, что не будет никакой возможности преобразовать int и double в новый тип, то тогда вызовутся нужные нам конструкторы:
```cpp
class Widget {
public:
    Widget (int i, bool b);    // Как и ранее
    Widget (int i, double d);  // Как и ранее
    
    Widget (std::initializer_list <std::string> (i)); // Теперь тип элемента - std::string
    
    // Нет функций неявного преобразования
};

Widget w0 (10, true);    // Вызов первого конструктора
Widget w1 {10, true};    // Вызов первого конструктора    
Widget w2 (10, 3.14);    // Вызов второго конструктора
Widget w3 {10, 3.14};    // Вызов второго конструктора
```

Теперь рассмотрим вызовы без аргументов:
```cpp
class Widget {
public:
    Widget (int i, bool b);    // Как и ранее
    Widget (int i, double d);  // Как и ранее
    
    Widget (std::initializer_list <int> (i));
    
    // Нет функций неявного преобразования
};

Widget w0;    // Вызов конструктора по умолчанию
Widget w1 {}; // Вызов конструктора по умолчанию
Widget w2 (); // Трактуется как объявление функции!!!
```

#### Пустые фигурные скобки означают отсутствие аргументов, а не пустой std::initializer_list

Если *хотите* вызвать конструктор с пустым std::initializer_list, то:
```cpp
Widget w3 ({}); // Вызов конструктора с пустым std::initializer_list
Widget w4 {{}}; // То же самое
```

И это достаточно повседневная практика. Давайте рассмотрим *std::vector <int>*:
```cpp
std::vector <int> v1 (10, 20); // Size: 10, каждый элемент имеет значение 20
std::vector <int> v2 {10, 20}; // Size:  2, первый равен 10, второй 20
```

А теперь крайне интересный пример. Предположим, что мы хотим создать объект произвольного типа с произвольным количеством аргументов:
```cpp
template <typename T,        // Тип объекта
          typename... Ts>    // Типы аргументов
void doSomeWork (Ts&&... params) {
    // Создание локального объекта
}
```

Рассмотрим два способа создания локального объекта:
```cpp
T localObject (std::forward <Ts> (params)...);    // Круглые скобки
T localObject {std::forward <Ts> (params)...};    // Фигурные скобки 
```

А вот самое интересное:
```cpp
std::vector <int> v;

doSomeWork <std::vector <int>> (10, 20);
```

Если локальный объект создавался при помощи круглых скобок, то создаться вектор из 10 элементов, если из фигурных, что из элементов 10 и 20.

### <center>Следует запомнить</center>
* Фигурная инициализация является наиболее широко используемым синтаксисом инициализации, предотвращающим сужающие преобразование и нечувствительным к особенностям синтаксического анализа C++.
* В процессе разрешения перегрузки конструкторов фигурные инициализаторы соответствуют параметрам *std:initializer_list*, если это возможно, даже если другие конструкторы обеспечивают лучшее соответствие.
* Пример, в котором выбор между круглыми и фигурными скобками приводит  к значительно отличающимся результатам, является создание *std::vector <числовой тип>* с двумя аргументами.
* Выбор между фигурными или круглыми скобками для создания объектов внутри шаблонов может быть очень сложным.

## 3.2 Предпочитайте *nullptr* значениям *0* и *NULL*

Тип *nullptr* - *std::nullptr_t*. *std::nullptr_t* неявно преобразуется во все типы указателей.

Важно понимать, что у *0* тип *int*, а у *NULL* либо *int*, либо *void**.  Поэтому иногда мы хотим вызвать функцию с аргументом NULL, которая принимает void*, а в действительности срабатывает перегрузка и вызывается функция с таким же именем, но принимающая int. Жуть.

Рассмотрим примеры, которые объяснят, почему лучше пользоваться *nullptr*, вместо *0* и *NULL*
```cpp
int func_sp (std::shared_ptr <Widget> spw);
int func_up (std::unique_ptr <Widget> upw);
int func_np (Widget* pw); // np - normal pointer

auto res_sp = func_sp (0);        // Это сработает, грустно
auto res_up = func_up (NULL);     // И это тоже сработает
auto res_np = func_np (nullptr);  // А это понятно, что сработает
```

Как видим это всё работает, но давайте напишем это на шаблонах:
```cpp
template <typename FuncType, typename PtrType>
decltype (auto) func (FuncType func, PtrType ptr) {    // C++14
    return func (ptr);
}
```

Теперь если мы запустим также, как в предыдущий раз, то получим что-то гораздо лучше:
```cpp
auto res_sp = func (func_sp, 0);        // Ошибка!
auto res_up = func (func_up, NULL);     // Ошибка!
auto res_np = func (func_np, nullptr);  // Ок
```

Это происходит потому, что *int* не совместим с типом *std::shared_ptr*. А *std::nullptr_t* совместим с любым указателем.

### <center>Следует запомнить</center>
* Предпочитайте применение *nullptr* использованию *0* или *NULL*
* Избегайте перегрузок с использованием целочисленных типов и типов к=указателей.

## 3.3 Предпочитайте объявление псевдонимов применению typedef









































